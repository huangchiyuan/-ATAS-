# BTC 风险监控模块说明

## 一、核心目的

**BTC 体制过滤器 (BTC Regime Filter)** 的核心目的不是为了预测方向，而是为了回答一个问题：

**"现在是不是'地震'（极端风险）时刻？"**

如果是地震时刻（如数据发布、战争新闻、币圈崩盘），所有基于相关性的微观模型都会失效，必须强制空仓。

---

## 二、核心原理

### 2.1 相对波动率 (Relative Volatility)

我们不能只看绝对值（比如"波动 > 100点"），因为 BTC 在 $20,000 和 $100,000 时的波动点数是不同的。

我们采用 **"当前 1分钟波动率 vs 过去 10分钟平均波动率"** 的比率。

### 2.2 算法步骤

1. **短期波动率 (Short-term Vol)**
   - 计算过去 **60秒** 内的价格标准差（对数收益率的标准差）
   - 反映当下的恐慌程度

2. **基准波动率 (Baseline Vol)**
   - 计算过去 **10分钟（600秒）** 的平均波动率
   - 反映背景噪音水平

3. **比率 (Ratio)**
   ```
   Ratio = Short-term Vol / Baseline Vol
   ```

4. **判定**
   - 如果 `Ratio > 3.0`（当前波动是平常的 3 倍）：**🔴 红灯 (Unsafe)**
   - 否则：**🟢 绿灯 (Safe)**

---

## 三、数学原理

### 3.1 对数收益率 (Log Returns)

波动率通常是对**收益率**求标准差，而不是对价格求标准差。

**公式**：
```
returns = ln(P_t / P_{t-1})
```

**为什么用对数收益率？**
- BTC 价格本身（如 90000）的标准差没有意义
- 只有**变化的百分比**的标准差（波动率）才有跨时间的可比性
- 对数收益率具有时间可加性，更适合计算波动率

### 3.2 波动率计算

```python
# 计算对数收益率
returns = np.diff(np.log(prices))

# 短期波动率（最近 60 秒）
short_vol = np.std(returns[-60:])

# 基准波动率（过去 10 分钟）
baseline_vol = np.std(returns)
```

---

## 四、工程优化

### 4.1 降频采样 (1Hz Sampling)

BTC 在活跃时一秒可能有 50 个 tick。如果每个 tick 都算标准差，CPU 会爆炸。

**解决方案**：每秒采样一次价格
- 足以捕捉"宏观惊吓"
- 计算成本降到几乎为零
- 秒级波动率更稳定

### 4.2 自适应基准

使用过去 10 分钟作为基准，这意味着：
- 如果 BTC 一直很疯（比如一直在暴涨），基准也会慢慢变大
- Ratio 就会降下来，解除警报
- 符合逻辑：**我们怕的不是波动大，而是"突然的、未预期的"剧烈波动**

---

## 五、代码实现

### 5.1 核心类：`BTCRegimeMonitor`

**位置**：`norden_v3/btc_regime.py`

**主要方法**：

1. **`on_tick(btc_price)`**
   - 每次收到 BTC tick 时调用
   - 内部会自动降频采样（每秒一次）

2. **`check_safety()`**
   - 返回 `True`：市场安全，可以交易
   - 返回 `False`：市场极端波动，应该强制空仓

3. **`get_stats()`**
   - 获取统计信息（波动率比率、短期/基准波动率等）

### 5.2 配置参数

**`BTCRegimeConfig`**：

- `short_window_seconds = 60`：短期窗口（1分钟）
- `long_window_seconds = 600`：长期窗口（10分钟）
- `alert_threshold = 3.0`：报警阈值（比率）
- `sample_interval_seconds = 1.0`：采样频率（1秒）

---

## 六、在策略中的应用

### 6.1 集成到策略引擎

在 `NordenMakerV3` 中已经自动集成：

```python
# 策略初始化时自动创建
self.btc_monitor = BTCRegimeMonitor()

# 每次 on_tick 时自动更新
def on_tick(self, tick):
    if tick.btc is not None:
        self.btc_monitor.on_tick(tick.btc)
    # ... 其他逻辑
```

### 6.2 Layer 3 风控过滤

在生成交易信号前自动检查：

```python
def _pass_filters(self, tick, want_long, want_short):
    # --- Layer 3: BTC 体制过滤（熔断机制）---
    if not self.btc_monitor.check_safety():
        # 市场不安全，拒绝所有交易信号
        return False
    
    # ... 其他过滤
```

**效果**：
- 如果检测到极端波动，所有交易信号都会被拦截
- 策略自动进入"假死"状态，保护账户

---

## 七、实战效果

### 7.1 正常市场

```
🟢 BTC:1.2x  # 当前波动是平时的 1.2 倍，正常
```

### 7.2 极端波动

```
🔴 BTC:3.5x  # 当前波动是平时的 3.5 倍，触发熔断
```

**典型场景**：
- CPI 数据发布瞬间
- 币圈交易所插针
- 重大新闻事件
- 战争/地缘政治风险

### 7.3 保护机制

当检测到极端波动时：
1. 所有新交易信号被拦截
2. 现有挂单保持（由超时机制自然取消）
3. 等待市场恢复正常后自动恢复交易

---

## 八、输出示例

在测试脚本中，BTC 状态会显示在状态行：

```
[STATUS] ES=6866.75 | Fair= 6866.79 Spread= +0.14tick | OBI=-0.135 | Queue: B=  71 A=  80 | 🟢 BTC:1.2x | Iceberg: None | Order: None
```

- `🟢 BTC:1.2x`：市场安全，波动率比率 1.2
- `🔴 BTC:3.5x`：市场极端波动，已触发熔断

---

## 九、调优建议

### 9.1 参数调整

| 参数 | 默认值 | 调优方向 | 说明 |
|------|--------|---------|------|
| `alert_threshold` | 3.0 | 增大 → 更宽松 | 提高触发熔断的阈值 |
| `short_window_seconds` | 60 | 减小 → 更敏感 | 缩短短期窗口 |
| `long_window_seconds` | 600 | 增大 → 更稳定 | 延长基准窗口 |

### 9.2 实战经验

- **正常交易时段**：比率通常在 1.0-2.0 之间
- **数据发布时段**：比率可能突然跳到 3.0-5.0
- **极端事件**：比率可能达到 5.0 以上

建议：
- 保守策略：`alert_threshold = 2.5`
- 激进策略：`alert_threshold = 4.0`
- 默认值 `3.0` 适合大多数情况

---

## 十、注意事项

1. **数据要求**：需要 BTC 价格数据（通过 UDP 流或数据源提供）
2. **初始化时间**：需要等待至少 60 秒才能产生有效判断
3. **计算成本**：极低，每秒只计算一次标准差
4. **误判风险**：正常波动也可能触发，但这是"宁可错杀，不可放过"的保护机制

---

*参考来源：基于相对波动率理论，结合实盘 HFT 风控最佳实践*

