# 模型输入数据归一化说明

## 一、归一化策略：基准扣除法 (Baseline Subtraction / 去中心化)

### 1.1 核心思想

**不是用绝对价格（如 NQ=21000, ES=6800），而是用“相对起点涨跌了多少点”作为输入。**

这样做的目的：
- **数值稳定**：输入数据从 `[21000, 44000, 6800]` 变成 `[10.5, -5.0, 2.0]`（都是 0 附近的数）
- **避免量级问题**：截距 Alpha 从几千变成接近 0，和斜率 Beta 在同一数量级
- **符合直觉**：模型真正学习的是“相关性”（NQ 涨 10 点，ES 应该涨 3 点）

---

## 二、具体实现流程

### 2.1 基准价格初始化（第一次运行）

**Kalman 模型**（`kalman_model.py` 第 126-133 行）：
```python
# 收到第一笔完整的 ES+NQ+YM 数据时
if self.base_es is None or self.base_nq is None or self.base_ym is None:
    self.base_es = es_raw      # 例如：6800.0
    self.base_nq = nq_raw      # 例如：21000.0
    self.base_ym = ym_raw      # 例如：44000.0
    self.last_fair = es_raw
    return es_raw, 0.0  # 第一笔不产生信号
```

**Ridge 模型**（`ridge_model.py` 第 104-112 行）：
```python
if self.base_prices["es"] is None:
    self.base_prices["nq"] = nq
    self.base_prices["ym"] = ym
    self.base_prices["es"] = es
    self.last_fair = es
    return es, 0.0
```

---

### 2.2 去中心化（后续每一笔数据）

**Kalman 模型**（第 135-142 行）：
```python
# 去中心化：只关心"相对涨跌多少点"
x_nq = nq_raw - self.base_nq      # 例如：21010.0 - 21000.0 = 10.0
x_ym = ym_raw - self.base_ym      # 例如：43995.0 - 44000.0 = -5.0
y_es = es_raw - self.base_es      # 例如：6802.0 - 6800.0 = 2.0

# 构造观测向量 H = [x_NQ, x_YM, 1]
H = np.array([x_nq, x_ym, 1.0])   # [10.0, -5.0, 1.0]
y = y_es                          # 2.0
```

**Ridge 模型**（第 114-121 行）：
```python
# 计算相对涨跌幅 (Delta)
x_nq = nq - self.base_prices["nq"]   # 相同逻辑
x_ym = ym - self.base_prices["ym"]
y_es = es - self.base_prices["es"]

# 构造特征向量 x = [NQ_delta, YM_delta, 1.0]
x = np.array([x_nq, x_ym, 1.0])
```

---

### 2.3 模型在去中心化空间工作

**Kalman 的预测**（第 145 行）：
```python
# 使用旧参数预测当前"相对"理论价
fair_delta = float(H.dot(self.theta))  # 例如：10.0 * 0.3 + (-5.0) * 0.05 + 0.0 = 2.75

# 这就是"ES 相对基准应该涨跌多少点"
```

**Ridge 的预测**（第 125 行）：
```python
y_pred_delta = float(x.dot(self.theta))  # 相同逻辑
```

**参数更新也在去中心化空间**：
- 误差 `error = y_es - fair_delta`（都是相对值）
- 更新 `theta += K * error`（Beta 和 Alpha 都是在相对空间中学习）

---

### 2.4 输出还原为绝对价格

**Kalman 模型**（第 165-167 行）：
```python
# 还原到绝对价格坐标
fair_abs = fair_delta + self.base_es  # 例如：2.75 + 6800.0 = 6802.75
spread = fair_abs - es_raw            # 例如：6802.75 - 6802.0 = 0.75
return fair_abs, spread
```

**Ridge 模型**（第 128-132 行）：
```python
# 还原为绝对价格
fair_price = y_pred_delta + float(self.base_prices["es"])

# 计算 Spread
spread = fair_price - es
return fair_price, spread
```

---

## 三、归一化效果对比

### 3.1 输入数据量级变化

| 阶段 | NQ | YM | ES | Alpha |
|------|----|----|----|----|
| **原始绝对价格** | 21000 | 44000 | 6800 | ~-10000 (为平衡巨大输入) |
| **去中心化后** | +10.5 | -5.0 | +2.0 | ~0.0 (合理范围) |

### 3.2 数学模型优势

**归一化前的问题：**
- Alpha 可能高达 ±10000，Beta 只有 0.3
- 岭回归的惩罚项会过度惩罚 Alpha，忽略 Beta
- 矩阵运算精度丢失（21000² = 4.4 亿）

**归一化后的优势：**
- Alpha 和 Beta 在同一数量级（0.1 ~ 1.0）
- 模型能公平地学习截距和斜率
- 数值稳定，收敛速度快

---

## 四、与可视化归一化的区别

### 4.1 模型内部归一化（去中心化）

**用途**：保证数学模型的数值稳定性  
**方法**：`value = price - base_price`  
**结果**：输入数据在 0 附近波动（点数差）

### 4.2 可视化归一化（基准索引法）

**用途**：在图表上直观比较不同品种的相对强弱  
**方法**：`value_norm = price / base_price * 100`  
**结果**：所有品种在起点都是 100，后续显示为百分比指数

**两者互不干扰**：
- 模型内部用“点数差”做计算（稳定）
- 可视化用“百分比指数”画图（直观）

---

## 五、关键代码位置总结

| 模型 | 基准初始化 | 去中心化 | 输出还原 |
|------|----------|---------|---------|
| **Kalman** | `kalman_model.py:126-133` | `kalman_model.py:135-142` | `kalman_model.py:165-167` |
| **Ridge** | `ridge_model.py:104-112` | `ridge_model.py:114-121` | `ridge_model.py:128-132` |

---

## 六、总结

1. **归一化方法**：基准扣除法（减去第一笔价格）
2. **归一化空间**：相对涨跌点数（不是绝对价格，也不是百分比）
3. **归一化目的**：数值稳定，避免量级问题
4. **输出还原**：加回 ES 基准价，得到绝对公允价和 Spread

**关键点：模型内部永远在"点数差"空间工作，只在输入/输出时做转换。**

