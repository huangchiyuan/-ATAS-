# 冰山订单检测模块说明

## 一、核心原理

### 1.1 冰山订单的定义

**冰山订单（Iceberg Order）**：指隐藏部分挂单量的订单。交易所只显示一部分挂单，当这部分被吃掉后，系统会自动补充新的挂单，直到全部成交。

### 1.2 检测方法

通过比较**成交量**和**可见挂单量**的差异来识别冰山：

- **正常情况**：
  - 成交量 = 可见挂单量 → 价格应该跳动（该档被吃完）
  
- **冰山订单**：
  - 成交量 > 可见挂单量，但价格未变 → 说明有隐藏订单在补充

### 1.3 检测算法

```
当发生成交时：
  1. 记录成交前最近的 DOM 状态（Best Bid/Ask 价格和挂单量）
  2. 如果成交是主动买入（BUY）：
     - 价格应该在 Ask 侧
     - 如果 成交量 >= Ask 挂单量，但 Ask 价格未变
     - → 发现 Ask 侧冰山（阻力）
  3. 如果成交是主动卖出（SELL）：
     - 价格应该在 Bid 侧  
     - 如果 成交量 >= Bid 挂单量，但 Bid 价格未变
     - → 发现 Bid 侧冰山（支撑）
```

---

## 二、代码实现

### 2.1 核心类：`IcebergDetector`

**位置**：`norden_v3/iceberg_detector.py`

**主要方法**：

1. **`on_dom(dom: DomSnapshot)`**
   - 更新当前盘口状态
   - 清理过期的冰山记录

2. **`on_trade(price, volume, side, timestamp_ms)`**
   - 处理单笔成交
   - 聚合同一毫秒内的多笔成交
   - 触发检测逻辑

3. **`get_resistance(price, range_ticks)`**
   - 查询上方阻力（Ask 侧冰山总量）

4. **`get_support(price, range_ticks)`**
   - 查询下方支撑（Bid 侧冰山总量）

### 2.2 数据流程

```
DOM 更新事件
  ↓
on_dom() → 更新盘口状态 + 处理缓存的成交
  ↓
成交事件
  ↓
on_trade() → 添加到缓存
  ↓
同一时间窗口内的成交聚合成一笔
  ↓
_detect_iceberg() → 比较成交量 vs 挂单量
  ↓
发现冰山 → 更新冰山地图
```

---

## 三、在策略中的应用

### 3.1 Layer 3 防御因子

在 `NordenMakerV3` 中，冰山检测作为防御因子：

```python
# 做多信号时，检查上方阻力
if want_long:
    if self.iceberg_detector.check_iceberg_resistance(price, direction=1):
        return  # 放弃交易
```

### 3.2 配置参数

**`IcebergConfig`**：

- `min_hidden_size = 10`：最小隐藏量阈值（过滤噪音）
- `decay_seconds = 60.0`：冰山记录的有效期（超过60秒认为失效）
- `check_range_ticks = 4`：检查阻力/支撑的价格范围（4个tick）

### 3.3 冰山地图

**数据结构**：`{price: hidden_volume}`

- **正数**：Ask 侧冰山（阻力，上方）
- **负数**：Bid 侧冰山（支撑，下方）
- **绝对值**：隐藏订单量（手数）

**示例**：
```python
iceberg_map = {
    6800.25: 150.0,   # 上方 6800.25 有 150 手隐藏卖单
    6799.75: -80.0,   # 下方 6799.75 有 80 手隐藏买单
}
```

---

## 四、实战使用示例

### 4.1 基本使用

```python
from norden_v3 import IcebergDetector, IcebergConfig, DomSnapshot, TickEvent

# 创建检测器
detector = IcebergDetector(IcebergConfig(min_hidden_size=10))

# 更新盘口
detector.on_dom(dom_snapshot)

# 处理成交
detector.on_trade(price=6800.25, volume=80, side="BUY", timestamp_ms=123456)

# 查询阻力
resistance = detector.get_resistance(current_price=6800.0, range_ticks=4)
if resistance > 200:
    print(f"上方有 {resistance} 手冰山阻力")
```

### 4.2 在策略引擎中

冰山检测器已经集成到 `NordenMakerV3` 中：

```python
# 自动调用（内部）
engine.on_dom(dom)  # → detector.on_dom(dom)
engine.on_tick(tick)  # → 如果收到成交，会自动调用 detector.on_trade()

# 决策时自动检查
if want_long:
    # 内部会调用 detector.check_iceberg_resistance(price, direction=1)
    if self._check_iceberg_resistance(price, direction=1):
        return  # 放弃交易
```

---

## 五、注意事项

### 5.1 数据时序问题

在实时流中，成交和 DOM 更新可能不同步。我们的实现：

- 使用**批量聚合**：聚合同一毫秒内的多笔成交
- 使用**最近 DOM 状态**：用最近一次 DOM 更新时的盘口状态来判断

### 5.2 误报问题

可能出现误报的情况：

1. **盘口更新延迟**：成交后盘口还没来得及更新
2. **多笔小单聚合**：多笔小单加起来超过挂单量，但实际没有冰山

**缓解措施**：
- 设置 `min_hidden_size` 阈值，过滤小冰山
- 使用时间衰减，旧记录自动失效

### 5.3 性能考虑

- 冰山地图最多保存几十条记录（每 60 秒自动清理）
- 查询阻力/支撑时使用线性搜索（范围小，性能可接受）
- 批量聚合减少检测次数

---

## 六、调优建议

### 6.1 参数调整

| 参数 | 默认值 | 调优方向 | 说明 |
|------|--------|---------|------|
| `min_hidden_size` | 10 | 增大 → 更保守 | 只记录较大的冰山 |
| `decay_seconds` | 60 | 减小 → 更敏感 | 冰山失效更快 |
| `check_range_ticks` | 4 | 增大 → 更全面 | 检查更大范围的阻力 |

### 6.2 实战经验

- **正常市场**：冰山较少，大部分时间 `iceberg_map` 为空
- **快市/波动大**：冰山较多，需要更严格的过滤
- **盘口薄**：更容易发现冰山（挂单量小，容易被穿透）

---

*参考来源：GitHub `fushuyue/Ml_HFT` 项目中的 `lookForIceberg.py`*

