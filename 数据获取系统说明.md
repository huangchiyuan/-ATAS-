# 量化交易系统 - 数据获取系统说明

## 一、整体架构

### 1.1 数据流向图

```
ATAS交易平台 (C#)
    ↓
UDP协议 (端口5555)
    ↓
Python数据接收层 (UdpListener线程)
    ↓
事件队列 (queue.Queue, 最大50000条)
    ↓
GUI主线程消费 (每50ms轮询)
    ↓
InstrumentState状态更新
    ↓
分析模块 / 可视化组件
```

### 1.2 系统组件

| 组件 | 语言 | 位置 | 功能 |
|------|------|------|------|
| **数据发送端** | C# | `NQ-YM指标（发送数据）/Class1.cs` | 从ATAS平台获取数据并发送到Python |
| **数据接收端** | Python | `dom_data_feed.py` | 接收UDP数据并解析 |
| **数据存储** | Python | `data_recorder_async_pandas.py` | 可选：将数据写入DuckDB数据库 |
| **数据读取** | Python | `data_reader.py` | 从DuckDB读取历史数据进行回测 |

---

## 二、C#端数据发送 (数据源)

### 2.1 核心类：`NFQE_Bridge_UDP`

**位置**：`NQ-YM指标（发送数据）/Class1.cs`

**主要功能**：
- 从ATAS平台订阅实时市场数据
- 通过UDP协议发送数据到Python端
- 智能缓冲：Tick数据立即发送，DOM数据批量发送

### 2.2 配置参数

```csharp
PythonIP = "127.0.0.1"      // Python监听地址
PythonPort = 5555            // UDP端口
DepthLevels = 15             // DOM深度配置（实际发送全部可见档位）
```

### 2.3 网络优化

- **发送缓冲区**：1MB (1024 * 1024 bytes)
- **刷新间隔**：50ms（定时刷新DOM缓冲区）
- **批量阈值**：8192 bytes（达到此大小立即发送）

### 2.4 发送的数据类型

#### 2.4.1 成交数据 (Trade/Tick)

**触发时机**：每次有新成交时 (`OnNewTrade`事件)

**消息格式**：
```
T,Symbol,Price,Volume,Side,ExchangeTimeTicks
```

**示例**：
```
T,ES,6849.25,5,BUY,638456789012345678
T,NQ,15234.50,10,SELL,638456789012345679
```

**字段说明**：
- `T`：消息类型（Trade）
- `Symbol`：合约代码（ES/NQ）
- `Price`：成交价格
- `Volume`：成交量
- `Side`：方向（BUY/SELL/NONE）
- `ExchangeTimeTicks`：交易所时间戳（.NET Ticks格式）

**发送策略**：
- **立即发送**（无缓冲）
- 体积小，延迟要求高（<1ms）
- 使用 `SendRaw()` 直接发送

#### 2.4.2 深度数据 (DOM)

**触发时机**：每次最佳买卖价变化时 (`OnBestBidAskChanged`事件)

**消息格式**：
```
D,Symbol,bid1@vol1|bid2@vol2|...,ask1@vol1|ask2@vol2|...,ExchangeTimeTicks
```

**示例**：
```
D,ES,6849.50@17|6849.25@28|6849.00@15,6849.75@12|6850.00@20|6850.25@8,638456789012345678
```

**字段说明**：
- `D`：消息类型（Depth）
- `Symbol`：合约代码
- `bids`：买盘档位，格式 `价格@成交量|价格@成交量|...`
  - 按价格从高到低排序
  - 如果没有买盘，发送 `0@0`
- `asks`：卖盘档位，格式 `价格@成交量|价格@成交量|...`
  - 按价格从低到高排序
  - 如果没有卖盘，发送 `0@0`
- `ExchangeTimeTicks`：交易所时间戳

**发送策略**：
- **批量缓冲发送**
- 数据量大，变化频繁
- 使用 `AddToBatch()` 加入缓冲区
- 50ms定时刷新 或 达到8KB阈值时发送
- **去重机制**：只有DOM数据真正变化时才发送

#### 2.4.3 心跳数据 (Heartbeat)

**触发时机**：每50ms定时器触发 (`OnTimerTick`事件)

**消息格式**：
```
H,Symbol,LocalTimeTicks
```

**用途**：检测连接状态

### 2.5 数据发送流程

```
ATAS平台事件触发
    ↓
OnNewTrade / OnBestBidAskChanged
    ↓
构建消息字符串
    ↓
Tick数据 → SendRaw() → 立即发送
DOM数据 → AddToBatch() → 批量缓冲
    ↓
定时器(50ms) 或 阈值触发 → FlushBatch()
    ↓
UDP发送到 Python (127.0.0.1:5555)
```

---

## 三、Python端数据接收

### 3.1 核心类：`UdpListener`

**位置**：`dom_data_feed.py`

**主要功能**：
- 在独立线程中监听UDP端口
- 解析接收到的消息
- 将解析后的事件放入线程安全队列

### 3.2 配置参数

```python
UDP_IP = "0.0.0.0"           # 监听所有网络接口
UDP_PORT = 5555              # UDP端口（与C#端对应）
DEPTH_LEVELS = 15            # 每边最大深度档数
DOM_ROWS = 30                # DOM总行数（DEPTH_LEVELS * 2）
PRICE_TICK = 0.25            # ES/NQ最小价位间距
MAX_TRADE_TIPS = 30          # 保留的成交记录数
REFRESH_INTERVAL_MS = 50     # GUI刷新间隔
```

### 3.3 数据接收流程

```python
# 创建UDP Socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.bind((UDP_IP, UDP_PORT))
sock.settimeout(1.0)

# 循环接收数据
while running:
    data, _ = sock.recvfrom(65535)  # 最大65KB
    text = data.decode(errors="ignore").strip()
    
    # 按行分割（可能包含多行消息）
    for line in text.split('\n'):
        parts = line.split(',')
        msg_type = parts[0]
        
        if msg_type == 'T':  # 成交数据
            event = {
                'type': 'T',
                'symbol': parts[1],
                'price': float(parts[2]),
                'volume': float(parts[3]),
                'side': parts[4],
                'ticks': parts[5],
            }
            queue.put(event)
        
        elif msg_type == 'D':  # DOM数据
            event = {
                'type': 'D',
                'symbol': parts[1],
                'bids': parts[2],
                'asks': parts[3],
                'ticks': parts[4],
            }
            queue.put(event)
```

### 3.4 队列管理

- **队列类型**：`queue.Queue`（线程安全）
- **最大容量**：50,000条消息
- **队列满时策略**：丢弃最旧的消息（FIFO）

```python
def _safe_put(self, event):
    try:
        self.out_queue.put_nowait(event)
    except queue.Full:
        # 队列满时，丢弃最旧元素
        try:
            _ = self.out_queue.get_nowait()
        except queue.Empty:
            pass
        self.out_queue.put_nowait(event)
```

---

## 四、数据解析与状态管理

### 4.1 核心类：`InstrumentState`

**位置**：`dom_data_feed.py`

**功能**：为每个交易品种（ES/NQ）维护实时状态

### 4.2 数据结构

```python
class InstrumentState:
    def __init__(self, symbol: str):
        self.symbol = symbol
        self.bids = [(0.0, 0)] * DEPTH_LEVELS      # 15档买盘 [(价格, 成交量), ...]
        self.asks = [(0.0, 0)] * DEPTH_LEVELS      # 15档卖盘
        self.trade_tips = deque(maxlen=30)         # 最近30笔成交记录
        self.last_price = 0.0                      # 最新成交价
        self.last_update = 0.0                     # 最后更新时间
```

### 4.3 DOM数据解析

**方法**：`_parse_levels()`

**解析逻辑**：

1. **输入格式**：`"price1@vol1|price2@vol2|..."`

2. **解析步骤**：
   ```python
   # 分割每个档位
   for item in raw.split('|'):
       if '@' not in item:
           continue
       parts = item.split('@')
       price = float(parts[0])
       vol = int(float(parts[1]))
       
       # 只保留有效的价格和成交量
       if price > 0 and vol > 0:
           all_levels.append((price, vol))
   ```

3. **智能筛选**：
   - 根据当前价格（`last_price`）筛选最靠近的15档
   - 买盘（Bids）：优先保留价格 ≤ 当前价格且最靠近的档位
   - 卖盘（Asks）：优先保留价格 ≥ 当前价格且最靠近的档位

4. **填充机制**：
   - 如果档位不足15档，用 `(0.0, 0)` 填充
   - 确保始终返回15档数据

**示例**：

假设C#发送了20档买盘，当前价格为6849.25：

```
C#发送（从高到低）：
6849.50@17, 6849.25@28, 6849.00@15, 6848.75@10, ...

Python解析后保留（最靠近当前价格的15档）：
[(6849.50, 17), (6849.25, 28), (6849.00, 15), ...]  # 15档
```

### 4.4 成交数据解析

**方法**：`add_trade()`

```python
def add_trade(self, price: float, volume: float, side: str, ticks_str: str):
    # 格式化成交记录
    tip = f"{time_str} {symbol} {side} {volume} @ {price:.2f}"
    
    # 添加到队列（自动限制为30条）
    self.trade_tips.appendleft(tip)
    
    # 更新最新成交价（用于DOM筛选）
    self.last_price = price
```

### 4.5 时间戳转换

**.NET Ticks 格式说明**：

- .NET Ticks：从 `0001-01-01 00:00:00` 开始的100纳秒间隔数
- Python Epoch：从 `1970-01-01 00:00:00` 开始的秒数

**转换公式**：

```python
TICKS_AT_EPOCH = 621355968000000000  # .NET Epoch偏移

def ticks_to_str(ticks: str) -> str:
    total_us = (int(ticks) - TICKS_AT_EPOCH) // 10
    seconds = total_us // 1_000_000
    tm = time.gmtime(seconds)
    return time.strftime("%H:%M:%S", tm)
```

---

## 五、数据消费与处理

### 5.1 GUI主线程消费

**位置**：`pyqt_dom_viewer.py`

**消费流程**：

```python
# 定时器每50ms触发一次
timer = QTimer()
timer.timeout.connect(self.consume_events)
timer.start(REFRESH_INTERVAL_MS)  # 50ms

def consume_events(self):
    while True:
        try:
            event = self.event_queue.get_nowait()
            
            # 按品种路由
            symbol = event['symbol']
            inst = self.instruments.get(symbol)
            if not inst:
                inst = InstrumentState(symbol)
                self.instruments[symbol] = inst
            
            # 更新状态
            if event['type'] == 'T':
                inst.add_trade(...)
            elif event['type'] == 'D':
                inst.update_dom(...)
            
            # 触发分析模块更新
            self.update_analysis_modules(inst)
            
        except queue.Empty:
            break
```

### 5.2 数据路由

- **ES数据** → ES分析模块 + ES可视化组件
- **NQ数据** → NQ分析模块 + NQ可视化组件

---

## 六、数据存储（可选）

### 6.1 异步数据录制器

**位置**：`data_recorder_async_pandas.py`

**功能**：
- 将实时数据写入DuckDB数据库
- 使用生产者-消费者模式
- 批量写入（50000条/批次）

**数据库结构**：

```sql
-- 成交表
CREATE TABLE ticks (
    symbol VARCHAR,
    price DOUBLE,
    volume DOUBLE,
    side VARCHAR,
    exchange_time TIMESTAMP,
    recv_time TIMESTAMP
);

-- DOM表
CREATE TABLE depth (
    symbol VARCHAR,
    bids VARCHAR,        -- 原始字符串格式
    asks VARCHAR,
    exchange_time TIMESTAMP,
    recv_time TIMESTAMP
);
```

**文件命名**：
- 格式：`market_data_YYYY-MM-DD.duckdb`
- 示例：`market_data_2025-11-20.duckdb`

### 6.2 数据读取（回测）

**位置**：`data_reader.py`

**功能**：
- 从DuckDB读取历史数据
- 解析DOM字符串为结构化数据
- 用于策略回测

**使用示例**：

```python
from data_reader import load_data_for_backtest

# 加载指定日期的数据
df_ticks, df_depth = load_data_for_backtest("2025-11-20", "ES")

# df_ticks: DataFrame，索引为交易所时间，列包括 price, volume, side
# df_depth: DataFrame，包含 parsed_bids 和 parsed_asks 列（已解析为列表）
```

---

## 七、数据流完整示例

### 7.1 成交数据流示例

```
1. ATAS平台：ES合约在6849.25成交5手，买方主动
   ↓
2. C# OnNewTrade事件触发
   ↓
3. 构建消息：T,ES,6849.25,5,BUY,638456789012345678
   ↓
4. SendRaw() 立即发送（UDP）
   ↓
5. Python UdpListener接收
   ↓
6. 解析为事件字典：
   {
       'type': 'T',
       'symbol': 'ES',
       'price': 6849.25,
       'volume': 5.0,
       'side': 'BUY',
       'ticks': '638456789012345678'
   }
   ↓
7. 放入事件队列
   ↓
8. GUI主线程消费（50ms内）
   ↓
9. 更新 InstrumentState：
   - inst.last_price = 6849.25
   - inst.trade_tips.appendleft("14:23:45 ES BUY    5 @ 6849.25")
   ↓
10. 触发分析模块更新（价值线、流动性等）
```

### 7.2 DOM数据流示例

```
1. ATAS平台：ES合约最佳买卖价变化
   买盘：6849.50@17, 6849.25@28, ...
   卖盘：6849.75@12, 6850.00@20, ...
   ↓
2. C# OnBestBidAskChanged事件触发
   ↓
3. 获取完整DOM快照
   ↓
4. 构建消息：
   D,ES,6849.50@17|6849.25@28|...,6849.75@12|6850.00@20|...,638456789012345678
   ↓
5. 检查是否变化（与上次对比）
   ↓
6. 如果变化，AddToBatch() 加入缓冲区
   ↓
7. 定时器50ms触发 或 达到8KB阈值
   ↓
8. FlushBatch() 发送所有缓冲的DOM数据
   ↓
9. Python UdpListener接收
   ↓
10. 解析为事件字典：
    {
        'type': 'D',
        'symbol': 'ES',
        'bids': '6849.50@17|6849.25@28|...',
        'asks': '6849.75@12|6850.00@20|...',
        'ticks': '638456789012345678'
    }
   ↓
11. 放入事件队列
   ↓
12. GUI主线程消费
   ↓
13. 调用 inst.update_dom(bids_str, asks_str)
   ↓
14. 解析并筛选最靠近当前价格的15档：
    inst.bids = [(6849.50, 17), (6849.25, 28), ...]  # 15档
    inst.asks = [(6849.75, 12), (6850.00, 20), ...]  # 15档
   ↓
15. 更新DOM表格显示
```

---

## 八、性能特点

### 8.1 延迟指标

| 环节 | 延迟 | 说明 |
|------|------|------|
| C# Tick发送 | <0.1ms | 立即发送，无缓冲 |
| UDP传输 | 0.1-1ms | 本地回环，延迟极低 |
| Python接收 | <1ms | Socket接收 |
| 队列等待 | 0-50ms | 最多等待一个GUI刷新周期 |
| 总延迟 | **<10ms** | 端到端延迟 |

### 8.2 吞吐量

- **Tick数据**：每秒数千笔（市场活跃时）
- **DOM数据**：每秒数十次更新
- **队列容量**：50,000条消息
- **缓冲区**：C#端8KB，Python端无限制（内存队列）

### 8.3 优化措施

1. **Tick数据立即发送**：无缓冲，最低延迟
2. **DOM数据批量发送**：减少网络开销
3. **线程分离**：UDP接收在独立线程，不阻塞GUI
4. **队列去重**：DOM数据去重，避免重复处理
5. **智能筛选**：只保留最相关的15档，减少内存占用

---

## 九、故障处理

### 9.1 网络异常

- **C#端**：忽略网络错误，保持运行（`catch { }`）
- **Python端**：Socket超时设置（1秒），避免无限阻塞

### 9.2 队列溢出

- **策略**：丢弃最旧消息（FIFO）
- **日志**：每5秒输出队列大小统计

### 9.3 数据解析错误

- **容错**：使用 `errors="ignore"` 解码
- **验证**：解析前检查格式
- **日志**：前3次错误输出调试信息

---

## 十、关键配置参数总结

| 参数 | C#端 | Python端 | 说明 |
|------|------|----------|------|
| **IP地址** | PythonIP = "127.0.0.1" | UDP_IP = "0.0.0.0" | 本地回环 |
| **端口** | PythonPort = 5555 | UDP_PORT = 5555 | 保持一致 |
| **DOM深度** | DepthLevels = 15 | DEPTH_LEVELS = 15 | 保持一致 |
| **刷新间隔** | Timer = 50ms | REFRESH_INTERVAL_MS = 50ms | GUI更新频率 |
| **发送缓冲区** | 1MB | - | C#端网络优化 |
| **批量阈值** | 8KB | - | DOM数据批量发送 |
| **队列容量** | - | 50,000条 | Python端事件队列 |

---

## 十一、扩展说明

### 11.1 增加DOM深度

如果要获取更多档位（例如20档）：

1. **C#端**：不需要修改（已发送全部可见档位）
2. **Python端**：
   ```python
   DEPTH_LEVELS = 20  # 修改为20
   DOM_ROWS = 40      # 自动变为40行
   ```

### 11.2 添加新的数据源

参考 `ATASDataGateway/Class1.cs`，使用WebSocket协议发送数据。

### 11.3 数据持久化

使用 `data_recorder_async_pandas.py` 录制数据到DuckDB，用于：
- 策略回测
- 数据分析
- 历史行情查询

---

*文档生成时间：2025-12*  
*项目版本：NFQE Lite v8.0*

